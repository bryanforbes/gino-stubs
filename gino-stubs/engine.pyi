from .transaction import GinoTransaction
from .dialects.base import Pool, _IterableCursor, PreparedStatement
from sqlalchemy.engine import Connection, Engine, Dialect
from sqlalchemy.sql.expression import ClauseElement
from sqlalchemy.sql.functions import FunctionElement
from sqlalchemy.schema import DDLElement, DefaultGenerator
from sqlalchemy.engine.interfaces import Compiled
from typing import Any, Optional, Union, Tuple, Type, Generator
import asyncio

StatementType = Union[str, ClauseElement, FunctionElement, DDLElement, DefaultGenerator]
StatementAndCompiledType = Union[StatementType, Compiled]

class _BaseDBAPIConnection:
    gino_conn: Any = ...
    def __init__(self, cursor_cls: Any) -> None: ...
    def commit(self) -> None: ...
    def cursor(self): ...
    @property
    def raw_connection(self) -> None: ...
    async def acquire(self, *, timeout: Optional[Any] = ...): ...
    async def release(self, permanent: Any): ...

class _DBAPIConnection(_BaseDBAPIConnection):
    def __init__(self, cursor_cls: Any, pool: Optional[Any] = ...) -> None: ...
    @property
    def raw_connection(self): ...

class _ReusingDBAPIConnection(_BaseDBAPIConnection):
    def __init__(self, cursor_cls: Any, root: Any) -> None: ...
    @property
    def raw_connection(self): ...

class _bypass_no_param:
    def keys(self): ...

class _SAConnection(Connection): ...

class _SAEngine(Engine):
    def __init__(self, dialect: Dialect, **kwargs: Any) -> None: ...

class _TransactionContext:
    async def __aenter__(self) -> GinoTransaction: ...
    async def __aexit__(self, *exc_info: Any) -> Optional[bool]: ...

class GinoConnection:
    schema_for_object: Any = ...
    def __init__(
        self, dialect: Dialect, sa_conn: Any, stack: Optional[Any] = ...
    ) -> None: ...
    @property
    def raw_connection(self): ...
    async def get_raw_connection(self, *, timeout: Optional[Any] = ...): ...
    async def release(self, *, permanent: bool = ...) -> None: ...
    @property
    def dialect(self) -> Dialect: ...
    async def all(self, clause: Any, *multiparams: Any, **params: Any): ...
    async def first(self, clause: Any, *multiparams: Any, **params: Any): ...
    async def scalar(self, clause: Any, *multiparams: Any, **params: Any): ...
    async def status(self, clause: Any, *multiparams: Any, **params: Any): ...
    def transaction(self, *args: Any, **kwargs: Any) -> GinoTransaction: ...
    def iterate(
        self, clause: Any, *multiparams: Any, **params: Any
    ) -> _IterableCursor[Any]: ...
    def execution_options(self, **opt: Any): ...
    async def prepare(self, clause: Any) -> PreparedStatement[Any]: ...

class _AcquireContext:
    def __init__(self, acquire: Any) -> None: ...
    async def __aenter__(self) -> GinoConnection: ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __await__(self) -> Generator[Any, None, GinoConnection]: ...

class GinoEngine:
    connection_cls: Type[GinoConnection]
    def __init__(
        self,
        dialect: Dialect,
        pool: Pool,
        loop: asyncio.AbstractEventLoop,
        logging_name: Optional[Any] = ...,
        echo: Optional[Any] = ...,
        execution_options: Optional[Any] = ...,
    ) -> None: ...
    @property
    def dialect(self) -> Dialect: ...
    @property
    def raw_pool(self) -> Any: ...
    def acquire(
        self,
        *,
        timeout: Optional[Any] = ...,
        reuse: bool = ...,
        lazy: bool = ...,
        reusable: bool = ...,
    ) -> _AcquireContext: ...
    @property
    def current_connection(self) -> Optional[GinoConnection]: ...
    async def close(self) -> None: ...
    async def all(self, clause: Any, *multiparams: Any, **params: Any): ...
    async def first(self, clause: Any, *multiparams: Any, **params: Any): ...
    async def scalar(self, clause: Any, *multiparams: Any, **params: Any): ...
    async def status(self, clause: Any, *multiparams: Any, **params: Any): ...
    def compile(
        self, clause: StatementType, *multiparams: Any, **params: Any
    ) -> Tuple[str, Any]: ...
    def transaction(
        self,
        *args: Any,
        timeout: Optional[Any] = ...,
        reuse: bool = ...,
        reusable: bool = ...,
        **kwargs: Any,
    ) -> _TransactionContext: ...
    def iterate(
        self, clause: Any, *multiparams: Any, **params: Any
    ) -> _IterableCursor[Any]: ...
    def update_execution_options(self, **opt: Any) -> None: ...
